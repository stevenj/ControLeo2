/*******************************************************************************
 * HEAVILY MODIFIED VERSION
* ControLeo Reflow Oven Controller
* Author: Peter Easton
* Website: whizoo.com
* Software written to work best on ControLeo2 (www.whizoo.com)
*
* This is an example of a reflow oven controller. The reflow curve below is for a
* lead-free profile.  The Reflow Wizard is capable of self-calibrating a reflow oven
* to the J-STD-20 reflow specification.
*
* Temperature (Degree Celcius)                 Magic Happens Here!
* 245-|                                               x  x  
*     |                                            x        x
*     |                                         x              x
*     |                                      x                    x
* 200-|                                   x                          x
*     |                              x    |                          |   x   
*     |                         x         |                          |       x
*     |                    x              |                          |
* 150-|               x                   |                          |
*     |             x |                   |                          |
*     |           x   |                   |                          | 
*     |         x     |                   |                          | 
*     |       x       |                   |                          | 
*     |     x         |                   |                          |
*     |   x           |                   |                          |
* 30 -| x             |                   |                          |
*     |<  60 - 90 s  >|<    60 - 120 s   >|<       60 - 150 s       >|
*     | Preheat Stage |   Soaking Stage   |       Reflow Stage       | Cool
*  0  |_ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
*                                                                Time (Seconds)
*
* This firmware builds on the work of other talented individuals:
* ==========================================
* Rocketscream (www.rocketscream.com)
* Produced the Arduino reflow oven shield and code that inspired this project.
*
* ==========================================
* Limor Fried of Adafruit (www.adafruit.com)
* Author of Arduino MAX6675 library. Adafruit has been the source of tonnes of
* tutorials, examples, and libraries for everyone to learn.
*
* Disclaimer
* ==========
* Dealing with high voltage is a very dangerous act! Please make sure you know
* what you are dealing with and have proper knowledge before hand. Your use of 
* any information or materials on this reflow oven controller is entirely at 
* your own risk, for which we shall not be liable. 
*
* Released under WTFPL license.
*
* Revision  Description
* ========  ===========
* 1.0       Initial public release. (21 October 2014)
* 1.1       Bug fixes (30 December 2014)
*           - Oven temperature might not reach configured maximum temperature
*           - Adjusted values so learning happens faster
*           - Other minor improvements
* 1.2       Improvements (6 January 2014)
*           - Take temperature readings every 0.125s and average them.  Fixes errors
*             generated by noise from convection fans
*           - Refined learning mode so learning should happen in fewer runs
*           - Improved loop duration timer to enhance timing
*           - Moved some strings from RAM to Flash (there is only 2.5Kb of RAM)
* 1.3       No user-facing changes (19 January 2015)
*           - Fixed compiler warnings for Arduino 1.5.8
* 1.4       Added support for servos (6 February 2015)
*           - When using a servo, please connect a large capacitor (e.g. 220uF, 16V)
*             between +5V and GND to avoid a microcontroller reset when the servo
*             stall current causes the voltage to drop.  Small servos may not need
*             a capacitor
*           - Connect the servo to +5V, GND and D3
*           - The open and close positions are configured in the Settings menu
*           - The oven door will open when the reflow is done, and close at 50C.
*             The door is also closed when ControLeo2 is turned on.
* 1.5       Minor improvements (15 July 2015)
*           - Made code easier to read by using “F” macro for strings stored in flash
*           - Minor adjustments to reflow values 
*           - Restrict the maximum duty cycle for the boost element to 60%.  It
*             should never need more than this!
*           - Make thermocouple more tolerant of transient errors, including
*             FAULT_OPEN
* 1.6       Added ability to bake (29 March 2016)
*           - Ability to bake was requested by a number of users, and was implemented
*             by Bernhard Kraft and Mark Foster.  Bernhard's implementation was added
*             to the code base.  This is a simple algorithm that only implements the
*             "P" (proportional) of the PID algorithm.  Temperatures may overshoot
*             initially, but for the rest of the baking time (up to 18 hours) the
*             temperature will be a few degrees below the target temperature.
*           - Added option to Setup menu to restart learning mode.
*           - Added option to Setup menu to reset to factory mode (erase everything)
* 1.7       Added support for cooling fan (7 June 2106)
*           - Any of the 4 outputs can be configured to control a cooling fan
*           - When bake finishes, the servo will open the oven door (thanks jcwren)
* 1.8       Major changes to bake functionality (22 June 2016)
*           - Complete rewrite of bake functionality.  Users reported that ControLeo2
*             would sometimes freeze during bake, leaving one or more elements on.
*           - Added Integral (the "I" of PID) to bake, so temperatures come closer
*             to desired bake temperature
*           - Added bake countdown timer to LCD screen
*           - Fixed bug where oven door would not close once bake completed.
* 1.9       Minor change to bake (25 June 2016)
*           - Initial bake duty cycle is based on desired bake temperature
* 2.0       Minor improvements (15 January 2017)
*           - Prevent bake/reflow before outputs are configured
*           - Limit top element to 80% power.  There is never a good reason to go 
*             higher than this.         
*           - Minor tweaks to learning mode, to reduce number of times this needs to
*             be run.
* 3.0       Heavily Modified, Changes to UI and Multiple profiles added.            
*           Eliminate Floating point.
*******************************************************************************/


// ***** INCLUDES *****
#include "ControLeo2.h"
#include "ReflowWizard.h"
#include "LcdFont.h"
#include "Tones.h"
#include "MD_Menu.h"

#define AUTO_START 0
#define MENU_TIMEOUT 10000

// ***** TYPE DEFINITIONS *****

ControLeo2_LCD       lcd;
ControLeo2_Buttons   buttons;
ControLeo2_MAX31855  temps;
extern MD_Menu M;

int mode = 0;

void setup() {
    // Log data to the computer using USB
    //uint32_t start = micros();
     
    // *********** Start of ControLeo2 initialization ***********
  
    // Set the relays as outputs and turn them off
    // The relay outputs are on D4 to D7 (4 outputs)
    for (int i=4; i<8; i++) {
        pinMode(i, OUTPUT);
        digitalWrite(i, LOW);
    }

    // Initialize the timer used to control the servo
    // initializeServo();
    
    // Initialize the Speaker
    initTones();

    Serial.begin(115200); 
    // wait for serial port to connect OR Timeout.
    //while ((!Serial) || ((micros() - start) > 1000000)) { } 
      
    Serial.println(FM("Reflow Wizard - ControLeo2 Oven Controller - V3.0"));

    // LCD Initialisation, Custom Font and Title Messages
    lcd.defineCustomChars(custom_chars);
    lcd.PrintStr(0,0, FM("ReflowWiz - V3.0"));
    lcd.ScrollLine(0,2,FM("Reflow Wizard - ControLeo2 Oven Controller - V3.0"));
    
  
    // Write the initial message on the LCD screen
    lcdPrintLine_P(0, PSTRM("   ControLeo2"));
    lcdPrintLine_P(1, PSTRM("Reflow Oven v3.0"));
    delay(100);
    playTones(TUNE_STARTUP);
    delay(3000);
    
    // Initialize the EEPROM, after flashing bootloader
    InitializeSettingsIfNeccessary();
    lcd.clear();
    
    // Go straight to reflow menu if learning is complete
    if (getSetting(SETTING_LEARNING_MODE) == false)
        mode = 2;
      
    // Make sure the oven door is closed
    setServoPosition(getSetting(SETTING_SERVO_CLOSED_DEGREES), 1000);


    M.begin();
    M.setMenuWrap(true);
    M.setAutoStart(AUTO_START);
    M.setTimeout(MENU_TIMEOUT);
  
    // *********** End of ControLeo2 initialization ***********
  
}


// The main menu has 4 options
const boolean (*action[NO_OF_MODES])() = {Testing, Config, Reflow, Bake};
const char* const modes[NO_OF_MODES] PROGMEM = {("Test Outputs?"), 
                                                ("Setup?"),
                                                ("Start Reflow?"),
                                                ("Start Baking?")};

#define DISPLAY_REFRESH_RATE_HZ (20)

// Refresh Periodic tasks, Thermocouple reading, Screen Overlay, Screen Drawing, Key Handling
void refresh()
{
    // Call this in the main loop, will cause display and temps to be updated as required.
    static unsigned long previous_time = 0;
    unsigned long current_time  = micros();
    int16_t temperature;
    
    temps.RefreshTemps();
    
    if ((current_time - previous_time) >= (1000000 / DISPLAY_REFRESH_RATE_HZ)) {
        // Get Latest Temperature Readings.
        // Draw Temperature Overlay on screen.
        // Temp is always shown in bottom left corner, and consumes 5 Characters.
        temperature = temps.readThermocouple(0);
        if (temperature < MAX_TEMPERATURE) {
            lcd.PrintInt(0,1,3,temps.readThermocouple(0));
            lcd.setChar(3, 1, 0x01); // Temperature Marking (Degrees C)
            lcd.setChar(4, 1, temps.readThermocoupleDrift()); // Temp Direction
        } else {
            lcd.PrintStr(0,1,temps.getFaultStr());                      
        }
        
        // Redraw screen.  
        lcd.refresh();

        previous_time = current_time;
    }
  
    // Handle Button input processing.
    buttons.ButtonProcessing();
}

void loop()
{
#if 0
  static boolean drawMenu = true;
  static boolean showMainMenu = true;
  static int counter = 0;
  static unsigned long nextLoopTime = 50; // Should be 3000 + 100 + fudge factor + 50 - but no harm making it 50!
#endif
  refresh();

  static bool prevMenuRun = true;

  // Detect if we need to initiate running normal user code
  if (prevMenuRun && !M.isInMenu())
    Serial.print("\n\nRUNNING USER'S NORMAL OPERATION\n");
  prevMenuRun = M.isInMenu();

  // If we are not running and not autostart
  // check if there is a reason to start the menu
  if (!M.isInMenu() && !AUTO_START)
  {
    uint16_t dummy;

    if (navigation(dummy) == MD_Menu::NAV_SEL)
      M.runMenu(true);
  }

  M.runMenu();   // just run the menu code


#if 0  
  if (showMainMenu) {
    if (drawMenu) {
      drawMenu = false;
      lcdPrintLine_P(0, modes[mode]);
      lcdPrintLine_P(1, PSTRM("          Yes ->"));
    }
        
    // Get the button press to select the mode or move to the next mode
    switch (buttons.GetKeypress()) {
    case BUTTON_TOP_RELEASE:
      // Move to the next mode
      mode = (mode + 1) % NO_OF_MODES;
      drawMenu = true;
      break;
    case BUTTON_BOT_RELEASE:
      // Move to the selected mode
      showMainMenu = false;
      drawMenu = true;
      break;
    }
  }
  else {
    // Go to the mode's menu system
    if ((*action[mode])() == NEXT_MODE)
      showMainMenu = true;
  }
  
  // Execute this loop 20 times per second (every 50ms). 
  if (millis() < nextLoopTime)
    delay(nextLoopTime - millis());
  nextLoopTime += 50;
#endif  
}

// Display a line on the LCD screen
// The provided string is padded to take up the whole line
// There is less flicker when overwriting characters on the screen, compared
// to clearing the screen and writing new information
void lcdPrintLine(int line, const char* str) {
  lcd.PrintStr(0,line, str);
}
// Same as above using PROGMEM to save SRAM
// works with constant strings only
void lcdPrintLine_P(int line, const char* str) {
  lcd.PrintStr(0,line, str);
}

bool display(MD_Menu::userDisplayAction_t action, char *msg)
{
  switch (action)
  {
  case MD_Menu::DISP_CLEAR:
    lcd.clear();
    break;

  case MD_Menu::DISP_L0:
    lcd.PrintStr(0,0, msg);
    break;

  case MD_Menu::DISP_L1:
    lcd.PrintStr(6, 1, msg);
    break;
  }

  return(true);
}

MD_Menu::userNavAction_t navigation(uint16_t &incDelta)
{
  uint8_t key = buttons.GetKeypress();

  switch (key) {
    case BUTTON_TOP_PRESS:        break;                    // Not Handled
    case BUTTON_TOP_RELEASE:      return(MD_Menu::NAV_INC); // Increment, if no Encoder
    case BUTTON_TOP_LONG_HOLD:    break;                    // Display HELP (To Implement)
    case BUTTON_TOP_LONG_RELEASE: break;                    // Not Handled

    case BUTTON_BOT_PRESS:        break;                    // Not Handled
    case BUTTON_BOT_RELEASE:      return(MD_Menu::NAV_SEL); // Select (Short Press)
    case BUTTON_BOT_LONG_HOLD:    return(MD_Menu::NAV_ESC); // Escape (Long Press)
    case BUTTON_BOT_LONG_RELEASE: break;                    // Not Handled

    case ENCODER_INC:             return(MD_Menu::NAV_INC); // Increment
    case ENCODER_DEC:             return(MD_Menu::NAV_DEC); // Decrement
  }

  return(MD_Menu::NAV_NULL);
}

// Global menu data and definitions
uint8_t fruit = 2;
bool bValue = true;
int8_t  int8Value = 99;
int16_t int16Value = 999;
int32_t int32Value = 9999;
float floatValue = 999.99;

// Menu Headers --------
const PROGMEM MD_Menu::mnuHeader_t mnuHdr[] =
{
  { 10, "MD_Menu",      10, 14, 0 },
  { 11, "Input Data",   20, 27, 0 },
  { 12, "Serial Setup", 30, 33, 0 },
  { 13, "LED Menu",     40, 41, 0 },
  { 14, "FF Menu",     50, 51, 0 },
};

// Menu Items ----------
const PROGMEM MD_Menu::mnuItem_t mnuItm[] =
{
  // Starting (Root) menu
  { 10, "Input Test", MD_Menu::MNU_MENU, 11 },
  { 11, "Serial",     MD_Menu::MNU_MENU, 12 },
  { 12, "LED",        MD_Menu::MNU_MENU, 13 },
  { 13, "More Menu",  MD_Menu::MNU_MENU, 10 },
  { 14, "Flip-Flop",  MD_Menu::MNU_MENU, 14 },
  // Input Data submenu
  { 20, "Fruit List", MD_Menu::MNU_INPUT, 10 },
  { 21, "Boolean",    MD_Menu::MNU_INPUT, 11 },
  { 22, "Integer 8",  MD_Menu::MNU_INPUT, 12 },
  { 23, "Integer 16", MD_Menu::MNU_INPUT, 13 },
  { 24, "Integer 32", MD_Menu::MNU_INPUT, 14 },
  { 25, "Hex 16",     MD_Menu::MNU_INPUT, 15 },
  { 26, "Float",      MD_Menu::MNU_INPUT, 16 },
  { 27, "Reset Menu", MD_Menu::MNU_INPUT, 17 },
  // Serial Setup
  { 30, "COM Port",  MD_Menu::MNU_INPUT, 30 },
  { 31, "Speed",     MD_Menu::MNU_INPUT, 31 },
  { 32, "Parity",    MD_Menu::MNU_INPUT, 32 },
  { 33, "Stop Bits", MD_Menu::MNU_INPUT, 33 },
  // LED  
  { 40, "Turn Off", MD_Menu::MNU_INPUT, 40 },
  { 41, "Turn On",  MD_Menu::MNU_INPUT, 41 },
  // Flip-flop - boolean controls variable edit
  { 50, "Flip", MD_Menu::MNU_INPUT, 50 },
  { 51, "Flop", MD_Menu::MNU_INPUT, 51 },
};

// Input Items ---------
const PROGMEM char listFruit[] = "Apple|Pear|Orange|Banana|Pineapple|Peach";
const PROGMEM char listCOM[] = "COM1|COM2|COM3|COM4";
const PROGMEM char listBaud[] = "9600|19200|57600|115200";
const PROGMEM char listParity[] = "O|E|N";
const PROGMEM char listStop[] = "0|1";

const PROGMEM MD_Menu::mnuInput_t mnuInp[] =
{
//  { 10, "List",    MD_Menu::INP_LIST,  mnuLValueRqst,  6,      0,      0,  0, .pList = listFruit }, // shorter and longer list labels
  { 10, "List",    MD_Menu::INP_LIST,  mnuLValueRqst,  6,      {.pList = listFruit }}, // shorter and longer list labels
  { 11, "Bool",    MD_Menu::INP_BOOL,  mnuBValueRqst,  1,      },
  { 12, "Int8",    MD_Menu::INP_INT8,  mnuIValueRqst,  4,      {.range = { .min=   -128, .max=    127, .base=10 } }},
  { 13, "Int16",   MD_Menu::INP_INT16, mnuIValueRqst,  4,      {.range = { .min= -32768, .max=  32767, .base=10 } }}, // -32768,  32767, 10, nullptr },  // test field too small
  { 14, "Int32",   MD_Menu::INP_INT32, mnuIValueRqst,  6,      {.range = { .min= -66636, .max=  65535, .base=10 } }}, // -66636,  65535, 10, nullptr },
  { 15, "Hex16",   MD_Menu::INP_INT16, mnuIValueRqst,  4,      {.range = { .min= 0x0000, .max= 0xFFFF, .base=16 } }}, //0x0000, 0xffff, 16, nullptr },  // test hex display
//  { 16, "Float",   MD_Menu::INP_FLOAT, mnuFValueRqst,  7, -10000,  99950, 10, nullptr },  // test float number
  { 16, "Confirm", MD_Menu::INP_RUN,   myCode,         0,      }, // 0, 0, 10, nullptr },

  { 30, "Port",     MD_Menu::INP_LIST, mnuSerialValueRqst, 4, {.pList = listCOM }}, //0, 0, 0, listCOM },
  { 31, "Bits/s",   MD_Menu::INP_LIST, mnuSerialValueRqst, 6, {.pList = listBaud }}, //0, 0, 0, listBaud },
  { 32, "Parity",   MD_Menu::INP_LIST, mnuSerialValueRqst, 1, {.pList = listParity }}, //0, 0, 0, listParity },
  { 33, "No. Bits", MD_Menu::INP_LIST, mnuSerialValueRqst, 1, {.pList = listStop }}, //0, 0, 0, listStop },

  { 40, "Confirm", MD_Menu::INP_RUN, myLEDCode, 0,  }, //0, 0, 0, nullptr },  // test using index in run code
  { 41, "Confirm", MD_Menu::INP_RUN, myLEDCode, 0,  }, //0, 0, 0, nullptr },

  { 50, "Flip", MD_Menu::INP_INT8, mnuFFValueRqst, 4, {.range = { .min= -128, .max= 127, .base=10 } }}, //-128, 127, 10, nullptr },
  { 51, "Flop", MD_Menu::INP_INT8, mnuFFValueRqst, 4, {.range = { .min= -128, .max= 127, .base=16 } }}, //-128, 127, 16, nullptr },
};

// bring it all together in the global menu object
MD_Menu M(navigation, display,        // user navigation and display
          mnuHdr, ARRAY_SIZE(mnuHdr), // menu header data
          mnuItm, ARRAY_SIZE(mnuItm), // menu item data
          mnuInp, ARRAY_SIZE(mnuInp));// menu input data
          
// Callback code for menu set/get input values
void *mnuLValueRqst(MD_Menu::mnuId_t id, bool bGet)
// Value request callback for list selection variable
{
  if (id == 10)
  {
    if (bGet)
      return((void *)&fruit);
    else
    {
      Serial.print(F("\nList index changed to "));
      Serial.print(fruit);
    }
  }
}

void *mnuBValueRqst(MD_Menu::mnuId_t id, bool bGet)
// Value request callback for boolean variable
{
  if (id == 11)
  {
    if (bGet)
      return((void *)&bValue);
    else
    {
      Serial.print(F("\nBoolean changed to "));
      Serial.print(bValue);
    }
  }
}

void *mnuIValueRqst(MD_Menu::mnuId_t id, bool bGet)
// Value request callback for integers variables
{
  switch (id)
  {
  case 12:
    if (bGet)
      return((void *)&int8Value);
    else
    {
      Serial.print(F("\nInt8 value changed to "));
      Serial.print(int8Value);
    }
    break;

  case 13:
  case 15:
    if (bGet)
      return((void *)&int16Value);
    else
    {
      Serial.print(F("\nInt16 value changed to "));
      Serial.print(int16Value);
    }
    break;

  case 14:
    if (bGet)
      return((void *)&int32Value);
    else
    {
      Serial.print(F("\nInt32 value changed to "));
      Serial.print(int32Value);
    }
    break;
  }

  return(nullptr);
}

void *mnuSerialValueRqst(MD_Menu::mnuId_t id, bool bGet)
// Value request callback for Serial parameters
{
  static uint8_t port = 0, speed = 0, parity = 0, stop = 0;

  switch (id)
  {
  case 30:
    if (bGet)
      return((void *)&port);
    else
    {
      Serial.print(F("\nPort index="));
      Serial.print(port);
    }
    break;

  case 31:
    if (bGet)
      return((void *)&speed);
    else
    {
      Serial.print(F("\nSpeed index="));
      Serial.print(speed);
    }
    break;

  case 32:
    if (bGet)
      return((void *)&parity);
    else
    {
      Serial.print(F("\nParity index="));
      Serial.print(parity);
    }
    break;

  case 33:
    if (bGet)
      return((void *)&stop);
    else
    {
      Serial.print(F("\nStop index="));
      Serial.print(stop);
    }
    break;
  }
  return(nullptr);
}
/*
void *mnuFValueRqst(MD_Menu::mnuId_t id, bool bGet)
// Value request callback for floating value
{
  static int32_t f;

  if (id == 16)
  {
    if (bGet)
    {
      f = (uint32_t)(floatValue * 100.0);
      return((void *)&f);
    }
    else
    {
      floatValue = (f / 100.0);
      Serial.print(F("\nFloat changed to "));
      Serial.print(floatValue);
    }
  }
}
*/
void *mnuFFValueRqst(MD_Menu::mnuId_t id, bool bGet)
// Value edit allowed request depends on another value
{
  static bool gateKeeper = false;
  static bool b;

  switch (id)
  {
  case 50:
    if (bGet)
    {
      if (gateKeeper)
      {
        Serial.print(F("\nFlipFlop value blocked"));
        return(nullptr);
      }
      else
        return((void *)&int8Value);
    }
    else
    {
      Serial.print(F("\nFlipFlop value changed to "));
      Serial.print(int8Value);
      gateKeeper = !gateKeeper;
    }
    break;

  case 51:
    if (bGet)
    {
      if (!gateKeeper)    // reverse the logic of above
      {
        Serial.print(F("\nFlipFlop value blocked"));
        return(nullptr);
      }
      else
        return((void *)&int8Value);
    }
    else
    {
      Serial.print(F("\nFlipFlop value changed to "));
      Serial.print(int8Value);
      gateKeeper = !gateKeeper;
    }
    break;
  }
}

void *myCode(MD_Menu::mnuId_t id, bool bGet)
// Value request callback for run code input
{
  Serial.print(F("\nmyCode called id="));
  Serial.print(id);
  Serial.print(F(" to "));
  Serial.print(bGet ? F("GET") : F("SET - reset menu"));

  if (!bGet) M.reset();
}

void *myLEDCode(MD_Menu::mnuId_t id, bool bGet)
// Value request callback for run code input
// Only use the index here
{
  Serial.print(F("\nSwitchig LED "));
  Serial.print(id == 40 ? F("off") : F("on"));
  // digitalWrite(LED_PIN, id == 40 ? LOW : HIGH);
}

